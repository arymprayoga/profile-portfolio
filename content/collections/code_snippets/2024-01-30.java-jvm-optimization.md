---
id: 7d4e5f6a-8b9c-0d1e-2f3a-4b5c6d7e8f9a
blueprint: code_snippet
title: 'Java JVM Performance Optimization'
description: 'Advanced JVM optimization techniques including garbage collection tuning, memory management, and high-performance data structures for enterprise applications.'
language: java
programming_languages:
  - java
difficulty: advanced
use_cases:
  - jvm-tuning
  - garbage-collection
  - enterprise-performance
  - memory-management
is_featured: false
external_link: null
status: published
date: 1706572800
---

```java
import java.util.*;
import java.util.concurrent.*;
import java.lang.ref.WeakReference;
import java.nio.ByteBuffer;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.LongAdder;

// 1. Object pooling to reduce GC pressure
public class ObjectPool<T> {
    private final Queue<T> pool = new ConcurrentLinkedQueue<>();
    private final Supplier<T> objectFactory;
    private final Consumer<T> resetFunction;
    private final int maxSize;
    private final AtomicInteger currentSize = new AtomicInteger(0);
    
    public ObjectPool(Supplier<T> objectFactory, Consumer<T> resetFunction, int maxSize) {
        this.objectFactory = objectFactory;
        this.resetFunction = resetFunction;
        this.maxSize = maxSize;
    }
    
    public T acquire() {
        T object = pool.poll();
        if (object == null) {
            object = objectFactory.get();
        } else {
            currentSize.decrementAndGet();
        }
        return object;
    }
    
    public void release(T object) {
        if (object != null && currentSize.get() < maxSize) {
            resetFunction.accept(object);
            pool.offer(object);
            currentSize.incrementAndGet();
        }
    }
    
    public int size() {
        return currentSize.get();
    }
}

// Usage example for StringBuilder pooling
class StringBuilderPool {
    private static final ObjectPool<StringBuilder> POOL = new ObjectPool<>(
        () -> new StringBuilder(256),
        StringBuilder::setLength,
        100
    );
    
    public static String buildString(String... parts) {
        StringBuilder sb = POOL.acquire();
        try {
            for (String part : parts) {
                sb.append(part);
            }
            return sb.toString();
        } finally {
            POOL.release(sb);
        }
    }
}

// 2. Lock-free data structures for high concurrency
public class LockFreeCounter {
    private final LongAdder counter = new LongAdder();
    private final AtomicInteger operations = new AtomicInteger(0);
    
    public void increment() {
        counter.increment();
        operations.incrementAndGet();
    }
    
    public void add(long value) {
        counter.add(value);
        operations.incrementAndGet();
    }
    
    public long sum() {
        return counter.sum();
    }
    
    public double averageValue() {
        int ops = operations.get();
        return ops > 0 ? (double) counter.sum() / ops : 0.0;
    }
}

// 3. Efficient batch processing with CompletableFuture
public class BatchProcessor<T, R> {
    private final Function<List<T>, List<R>> batchFunction;
    private final int batchSize;
    private final int maxWaitMs;
    private final ExecutorService executor;
    
    private final Queue<BatchItem<T, R>> pending = new ConcurrentLinkedQueue<>();
    private final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);
    
    public BatchProcessor(Function<List<T>, List<R>> batchFunction, 
                         int batchSize, int maxWaitMs, ExecutorService executor) {
        this.batchFunction = batchFunction;
        this.batchSize = batchSize;
        this.maxWaitMs = maxWaitMs;
        this.executor = executor;
        
        // Schedule periodic batch processing
        scheduler.scheduleAtFixedRate(this::processPendingBatches, 
                                    maxWaitMs, maxWaitMs, TimeUnit.MILLISECONDS);
    }
    
    public CompletableFuture<R> process(T item) {
        CompletableFuture<R> future = new CompletableFuture<>();
        pending.offer(new BatchItem<>(item, future));
        
        if (pending.size() >= batchSize) {
            processPendingBatches();
        }
        
        return future;
    }
    
    private void processPendingBatches() {
        List<BatchItem<T, R>> batch = new ArrayList<>();
        BatchItem<T, R> item;
        
        while (batch.size() < batchSize && (item = pending.poll()) != null) {
            batch.add(item);
        }
        
        if (!batch.isEmpty()) {
            CompletableFuture.supplyAsync(() -> {
                List<T> inputs = batch.stream()
                    .map(BatchItem::getInput)
                    .collect(Collectors.toList());
                return batchFunction.apply(inputs);
            }, executor).thenAccept(results -> {
                for (int i = 0; i < batch.size() && i < results.size(); i++) {
                    batch.get(i).getFuture().complete(results.get(i));
                }
            }).exceptionally(throwable -> {
                batch.forEach(batchItem -> 
                    batchItem.getFuture().completeExceptionally(throwable));
                return null;
            });
        }
    }
    
    private static class BatchItem<T, R> {
        private final T input;
        private final CompletableFuture<R> future;
        
        public BatchItem(T input, CompletableFuture<R> future) {
            this.input = input;
            this.future = future;
        }
        
        public T getInput() { return input; }
        public CompletableFuture<R> getFuture() { return future; }
    }
}

// 4. Memory-efficient cache with weak references
public class WeakReferenceCache<K, V> {
    private final Map<K, WeakReference<V>> cache = new ConcurrentHashMap<>();
    private final Function<K, V> valueLoader;
    private final ScheduledExecutorService cleaner;
    
    public WeakReferenceCache(Function<K, V> valueLoader) {
        this.valueLoader = valueLoader;
        this.cleaner = Executors.newScheduledThreadPool(1);
        
        // Clean up expired references every 5 minutes
        cleaner.scheduleAtFixedRate(this::cleanup, 5, 5, TimeUnit.MINUTES);
    }
    
    public V get(K key) {
        WeakReference<V> ref = cache.get(key);
        V value = null;
        
        if (ref != null) {
            value = ref.get();
        }
        
        if (value == null) {
            value = valueLoader.apply(key);
            cache.put(key, new WeakReference<>(value));
        }
        
        return value;
    }
    
    private void cleanup() {
        cache.entrySet().removeIf(entry -> entry.getValue().get() == null);
    }
    
    public int size() {
        return cache.size();
    }
    
    public void shutdown() {
        cleaner.shutdown();
    }
}

// 5. Off-heap storage for large datasets
public class OffHeapBuffer {
    private final ByteBuffer buffer;
    private final int capacity;
    
    public OffHeapBuffer(int capacity) {
        this.capacity = capacity;
        this.buffer = ByteBuffer.allocateDirect(capacity);
    }
    
    public void writeInt(int position, int value) {
        buffer.putInt(position, value);
    }
    
    public int readInt(int position) {
        return buffer.getInt(position);
    }
    
    public void writeLong(int position, long value) {
        buffer.putLong(position, value);
    }
    
    public long readLong(int position) {
        return buffer.getLong(position);
    }
    
    public void writeBytes(int position, byte[] data) {
        buffer.position(position);
        buffer.put(data);
    }
    
    public byte[] readBytes(int position, int length) {
        byte[] data = new byte[length];
        buffer.position(position);
        buffer.get(data);
        return data;
    }
    
    public boolean isDirect() {
        return buffer.isDirect();
    }
    
    public int capacity() {
        return capacity;
    }
}

// 6. JVM monitoring and performance metrics
public class PerformanceMonitor {
    private final MemoryMXBean memoryBean;
    private final List<GarbageCollectorMXBean> gcBeans;
    private final ThreadMXBean threadBean;
    
    public PerformanceMonitor() {
        this.memoryBean = ManagementFactory.getMemoryMXBean();
        this.gcBeans = ManagementFactory.getGarbageCollectorMXBeans();
        this.threadBean = ManagementFactory.getThreadMXBean();
    }
    
    public MemoryUsage getHeapMemoryUsage() {
        return memoryBean.getHeapMemoryUsage();
    }
    
    public MemoryUsage getNonHeapMemoryUsage() {
        return memoryBean.getNonHeapMemoryUsage();
    }
    
    public Map<String, Long> getGCStats() {
        Map<String, Long> gcStats = new HashMap<>();
        
        for (GarbageCollectorMXBean gcBean : gcBeans) {
            gcStats.put(gcBean.getName() + "_collections", gcBean.getCollectionCount());
            gcStats.put(gcBean.getName() + "_time", gcBean.getCollectionTime());
        }
        
        return gcStats;
    }
    
    public ThreadInfo[] getThreadDump() {
        return threadBean.dumpAllThreads(true, true);
    }
    
    public void printMemoryStats() {
        MemoryUsage heapUsage = getHeapMemoryUsage();
        MemoryUsage nonHeapUsage = getNonHeapMemoryUsage();
        
        System.out.printf("Heap Memory: Used=%d MB, Max=%d MB, Usage=%.2f%%\n",
            heapUsage.getUsed() / (1024 * 1024),
            heapUsage.getMax() / (1024 * 1024),
            (double) heapUsage.getUsed() / heapUsage.getMax() * 100);
            
        System.out.printf("Non-Heap Memory: Used=%d MB, Max=%d MB\n",
            nonHeapUsage.getUsed() / (1024 * 1024),
            nonHeapUsage.getMax() / (1024 * 1024));
        
        getGCStats().forEach((name, value) -> 
            System.out.printf("GC %s: %d\n", name, value));
    }
}

// Usage examples and performance testing
public class PerformanceExample {
    public static void main(String[] args) {
        // Test object pooling
        testObjectPooling();
        
        // Test batch processing
        testBatchProcessing();
        
        // Monitor performance
        PerformanceMonitor monitor = new PerformanceMonitor();
        monitor.printMemoryStats();
    }
    
    private static void testObjectPooling() {
        long start = System.nanoTime();
        
        for (int i = 0; i < 100000; i++) {
            String result = StringBuilderPool.buildString("Hello", " ", "World", " ", String.valueOf(i));
        }
        
        long duration = System.nanoTime() - start;
        System.out.printf("Object pooling test took: %.2f ms\n", duration / 1_000_000.0);
    }
    
    private static void testBatchProcessing() {
        ExecutorService executor = ForkJoinPool.commonPool();
        BatchProcessor<Integer, String> processor = new BatchProcessor<>(
            batch -> batch.stream().map(Object::toString).collect(Collectors.toList()),
            10, 100, executor
        );
        
        List<CompletableFuture<String>> futures = new ArrayList<>();
        for (int i = 0; i < 1000; i++) {
            futures.add(processor.process(i));
        }
        
        // Wait for all results
        CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))
            .thenRun(() -> System.out.println("Batch processing completed"));
    }
}
```