---
id: 8e5f6a7b-9c0d-1e2f-3a4b-5c6d7e8f9a0b
blueprint: code_snippet
title: 'C# .NET High-Performance Optimization'
description: 'Advanced .NET performance optimization techniques including Span<T>, memory pooling, async optimization, and SIMD operations for high-throughput applications.'
language: csharp
programming_languages:
  - csharp
difficulty: advanced
use_cases:
  - dotnet-performance
  - memory-optimization
  - async-optimization
  - high-throughput
is_featured: false
external_link: null
status: published
date: 1706313600
---

```csharp
using System;
using System.Buffers;
using System.Collections.Concurrent;
using System.Numerics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Threading;
using System.Threading.Channels;
using System.Threading.Tasks;

// 1. Zero-allocation string operations with Span<T>
public static class SpanOptimizations
{
    // Parse integers without allocation
    public static bool TryParseInt32(ReadOnlySpan<char> span, out int result)
    {
        result = 0;
        if (span.IsEmpty) return false;
        
        int sign = 1;
        int index = 0;
        
        if (span[0] == '-')
        {
            sign = -1;
            index = 1;
        }
        
        for (int i = index; i < span.Length; i++)
        {
            char c = span[i];
            if (c < '0' || c > '9') return false;
            
            result = result * 10 + (c - '0');
        }
        
        result *= sign;
        return true;
    }
    
    // Fast string splitting without allocations
    public static void SplitString(ReadOnlySpan<char> input, char separator, 
                                  Action<ReadOnlySpan<char>> onSegment)
    {
        int start = 0;
        for (int i = 0; i < input.Length; i++)
        {
            if (input[i] == separator)
            {
                if (i > start)
                {
                    onSegment(input.Slice(start, i - start));
                }
                start = i + 1;
            }
        }
        
        // Handle last segment
        if (start < input.Length)
        {
            onSegment(input.Slice(start));
        }
    }
    
    // Memory-efficient string comparison
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool FastEquals(ReadOnlySpan<char> a, ReadOnlySpan<char> b)
    {
        return a.SequenceEqual(b);
    }
}

// 2. High-performance object pooling with ArrayPool
public class PooledBuffer<T> : IDisposable
{
    private T[] _buffer;
    private readonly ArrayPool<T> _pool;
    private bool _disposed;
    
    public PooledBuffer(int minimumLength, ArrayPool<T> pool = null)
    {
        _pool = pool ?? ArrayPool<T>.Shared;
        _buffer = _pool.Rent(minimumLength);
    }
    
    public Span<T> Span => _buffer.AsSpan();
    public T[] Array => _buffer;
    public int Length => _buffer.Length;
    
    public void Dispose()
    {
        if (!_disposed && _buffer != null)
        {
            _pool.Return(_buffer, clearArray: true);
            _buffer = null;
            _disposed = true;
        }
    }
}

// Usage example for high-performance data processing
public class DataProcessor
{
    private static readonly ArrayPool<byte> BytePool = ArrayPool<byte>.Shared;
    
    public async Task<ProcessResult> ProcessDataAsync(ReadOnlyMemory<byte> data)
    {
        using var buffer = new PooledBuffer<byte>(data.Length * 2);
        
        // Process data without additional allocations
        data.Span.CopyTo(buffer.Span);
        
        // Simulate processing
        await Task.Delay(1, CancellationToken.None);
        
        return new ProcessResult { ProcessedBytes = data.Length };
    }
}

// 3. Lock-free concurrent collections
public class LockFreeQueue<T>
{
    private readonly Channel<T> _channel;
    private readonly ChannelWriter<T> _writer;
    private readonly ChannelReader<T> _reader;
    
    public LockFreeQueue(int capacity = 1000)
    {
        var options = new BoundedChannelOptions(capacity)
        {
            FullMode = BoundedChannelFullMode.Wait,
            SingleReader = false,
            SingleWriter = false,
            AllowSynchronousContinuations = false
        };
        
        _channel = Channel.CreateBounded<T>(options);
        _writer = _channel.Writer;
        _reader = _channel.Reader;
    }
    
    public async ValueTask<bool> TryEnqueueAsync(T item, CancellationToken cancellationToken = default)
    {
        return await _writer.WaitToWriteAsync(cancellationToken) && 
               _writer.TryWrite(item);
    }
    
    public async ValueTask<(bool Success, T Item)> TryDequeueAsync(CancellationToken cancellationToken = default)
    {
        if (await _reader.WaitToReadAsync(cancellationToken))
        {
            if (_reader.TryRead(out T item))
            {
                return (true, item);
            }
        }
        return (false, default(T));
    }
    
    public void CompleteAdding() => _writer.Complete();
}

// 4. SIMD-optimized numerical operations
public static class SIMDOperations
{
    public static void MultiplyArrays(ReadOnlySpan<float> a, ReadOnlySpan<float> b, Span<float> result)
    {
        if (a.Length != b.Length || result.Length < a.Length)
            throw new ArgumentException("Array dimensions mismatch");
        
        int simdLength = Vector<float>.Count;
        int i = 0;
        
        // Process SIMD-sized chunks
        for (; i <= a.Length - simdLength; i += simdLength)
        {
            var vectorA = new Vector<float>(a.Slice(i, simdLength));
            var vectorB = new Vector<float>(b.Slice(i, simdLength));
            var vectorResult = vectorA * vectorB;
            
            vectorResult.CopyTo(result.Slice(i, simdLength));
        }
        
        // Process remaining elements
        for (; i < a.Length; i++)
        {
            result[i] = a[i] * b[i];
        }
    }
    
    public static float DotProduct(ReadOnlySpan<float> a, ReadOnlySpan<float> b)
    {
        if (a.Length != b.Length)
            throw new ArgumentException("Vector dimensions must match");
        
        float result = 0f;
        int simdLength = Vector<float>.Count;
        var accumulatorVector = Vector<float>.Zero;
        int i = 0;
        
        // SIMD processing
        for (; i <= a.Length - simdLength; i += simdLength)
        {
            var vectorA = new Vector<float>(a.Slice(i, simdLength));
            var vectorB = new Vector<float>(b.Slice(i, simdLength));
            accumulatorVector += vectorA * vectorB;
        }
        
        // Sum the accumulator vector
        for (int j = 0; j < simdLength; j++)
        {
            result += accumulatorVector[j];
        }
        
        // Process remaining elements
        for (; i < a.Length; i++)
        {
            result += a[i] * b[i];
        }
        
        return result;
    }
}

// 5. Async optimization patterns
public class AsyncOptimizer
{
    private readonly SemaphoreSlim _semaphore;
    
    public AsyncOptimizer(int maxConcurrency = Environment.ProcessorCount)
    {
        _semaphore = new SemaphoreSlim(maxConcurrency, maxConcurrency);
    }
    
    // Optimized async enumerable processing
    public async IAsyncEnumerable<TResult> ProcessAsync<TSource, TResult>(
        IAsyncEnumerable<TSource> source,
        Func<TSource, ValueTask<TResult>> processor,
        [EnumeratorCancellation] CancellationToken cancellationToken = default)
    {
        var tasks = new List<Task<TResult>>();
        const int batchSize = 100;
        
        await foreach (var item in source.WithCancellation(cancellationToken))
        {
            await _semaphore.WaitAsync(cancellationToken);
            
            tasks.Add(ProcessItemAsync(item, processor));
            
            if (tasks.Count >= batchSize)
            {
                var completed = await Task.WhenAny(tasks);
                tasks.Remove(completed);
                yield return await completed;
            }
        }
        
        // Process remaining items
        while (tasks.Count > 0)
        {
            var completed = await Task.WhenAny(tasks);
            tasks.Remove(completed);
            yield return await completed;
        }
    }
    
    private async Task<TResult> ProcessItemAsync<TSource, TResult>(
        TSource item, 
        Func<TSource, ValueTask<TResult>> processor)
    {
        try
        {
            return await processor(item);
        }
        finally
        {
            _semaphore.Release();
        }
    }
}

// 6. Memory-mapped file processing for large datasets
public class MemoryMappedProcessor : IDisposable
{
    private readonly MemoryMappedFile _mmf;
    private readonly MemoryMappedViewAccessor _accessor;
    private bool _disposed;
    
    public MemoryMappedProcessor(string filePath, long capacity)
    {
        _mmf = MemoryMappedFile.CreateFromFile(filePath, FileMode.OpenOrCreate, "data", capacity);
        _accessor = _mmf.CreateViewAccessor(0, capacity);
    }
    
    public unsafe Span<T> GetSpan<T>(long offset, int count) where T : unmanaged
    {
        byte* ptr = (byte*)_accessor.SafeMemoryMappedViewHandle.DangerousGetHandle() + offset;
        return new Span<T>(ptr, count);
    }
    
    public void WriteStruct<T>(long offset, in T value) where T : unmanaged
    {
        _accessor.Write(offset, ref Unsafe.AsRef(in value));
    }
    
    public T ReadStruct<T>(long offset) where T : unmanaged
    {
        _accessor.Read(offset, out T value);
        return value;
    }
    
    public void Dispose()
    {
        if (!_disposed)
        {
            _accessor?.Dispose();
            _mmf?.Dispose();
            _disposed = true;
        }
    }
}

// Performance measurement utilities
public class PerformanceMeasurement
{
    public static async Task<TimeSpan> MeasureAsync(Func<Task> operation)
    {
        var stopwatch = System.Diagnostics.Stopwatch.StartNew();
        await operation();
        stopwatch.Stop();
        return stopwatch.Elapsed;
    }
    
    public static TimeSpan Measure(Action operation)
    {
        var stopwatch = System.Diagnostics.Stopwatch.StartNew();
        operation();
        stopwatch.Stop();
        return stopwatch.Elapsed;
    }
    
    public static async Task<(T Result, TimeSpan Duration)> MeasureAsync<T>(Func<Task<T>> operation)
    {
        var stopwatch = System.Diagnostics.Stopwatch.StartNew();
        var result = await operation();
        stopwatch.Stop();
        return (result, stopwatch.Elapsed);
    }
}

// Usage examples
public class ProcessResult
{
    public int ProcessedBytes { get; set; }
}

public class PerformanceExample
{
    public static async Task Main(string[] args)
    {
        // Test SIMD operations
        TestSIMDOperations();
        
        // Test async processing
        await TestAsyncProcessing();
        
        // Test memory pooling
        TestMemoryPooling();
    }
    
    private static void TestSIMDOperations()
    {
        var a = new float[1000];
        var b = new float[1000];
        var result = new float[1000];
        
        // Initialize arrays
        for (int i = 0; i < 1000; i++)
        {
            a[i] = i;
            b[i] = i * 2;
        }
        
        var duration = PerformanceMeasurement.Measure(() =>
        {
            SIMDOperations.MultiplyArrays(a, b, result);
        });
        
        Console.WriteLine($"SIMD multiplication took: {duration.TotalMicroseconds:F2} μs");
    }
    
    private static async Task TestAsyncProcessing()
    {
        var optimizer = new AsyncOptimizer(maxConcurrency: 4);
        var source = GenerateAsyncData();
        
        var count = 0;
        await foreach (var result in optimizer.ProcessAsync(source, ProcessItemAsync))
        {
            count++;
        }
        
        Console.WriteLine($"Processed {count} items asynchronously");
    }
    
    private static async IAsyncEnumerable<int> GenerateAsyncData()
    {
        for (int i = 0; i < 1000; i++)
        {
            yield return i;
            await Task.Delay(1); // Simulate async data source
        }
    }
    
    private static async ValueTask<string> ProcessItemAsync(int item)
    {
        await Task.Delay(1); // Simulate async processing
        return $"Processed: {item}";
    }
    
    private static void TestMemoryPooling()
    {
        var duration = PerformanceMeasurement.Measure(() =>
        {
            for (int i = 0; i < 10000; i++)
            {
                using var buffer = new PooledBuffer<byte>(1024);
                // Use buffer...
                buffer.Span.Fill((byte)(i % 256));
            }
        });
        
        Console.WriteLine($"Memory pooling test took: {duration.TotalMilliseconds:F2} ms");
    }
}
```