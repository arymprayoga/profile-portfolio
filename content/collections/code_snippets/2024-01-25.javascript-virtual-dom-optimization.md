---
id: 4a1b2c3d-5e6f-7a8b-9c0d-1e2f3a4b5c6d
blueprint: code_snippet
title: 'JavaScript Virtual DOM Optimization Techniques'
description: 'Advanced performance optimization patterns for React/Vue applications including memoization, lazy loading, and efficient rendering strategies.'
language: javascript
programming_languages:
  - javascript
difficulty: advanced
use_cases:
  - frontend-optimization
  - react-performance
  - virtual-dom
  - web-performance
is_featured: true
external_link: null
status: published
date: 1706140800
---

```javascript
// 1. React.memo with custom comparison for expensive renders
import React, { memo, useMemo, useCallback } from 'react';

const ExpensiveComponent = memo(({ data, onUpdate }) => {
  // Memoize expensive calculations
  const processedData = useMemo(() => {
    console.log('Processing data...');
    return data.map(item => ({
      ...item,
      computed: item.value * Math.sqrt(item.factor)
    }));
  }, [data]);

  // Memoize callback to prevent child re-renders
  const handleItemClick = useCallback((id) => {
    onUpdate(id);
  }, [onUpdate]);

  return (
    <div>
      {processedData.map(item => (
        <ItemComponent 
          key={item.id} 
          item={item} 
          onClick={handleItemClick}
        />
      ))}
    </div>
  );
}, (prevProps, nextProps) => {
  // Custom comparison - only re-render if data actually changed
  return JSON.stringify(prevProps.data) === JSON.stringify(nextProps.data);
});

// 2. Virtualized list for handling large datasets
import { FixedSizeList as List } from 'react-window';

const VirtualizedList = ({ items }) => {
  const Row = ({ index, style }) => (
    <div style={style}>
      <div className="list-item">
        {items[index].name}
      </div>
    </div>
  );

  return (
    <List
      height={600}
      itemCount={items.length}
      itemSize={50}
      width="100%"
    >
      {Row}
    </List>
  );
};

// 3. Debounced search with cleanup
import { useState, useEffect, useRef } from 'react';

const useDebounce = (value, delay) => {
  const [debouncedValue, setDebouncedValue] = useState(value);
  const timeoutRef = useRef();

  useEffect(() => {
    timeoutRef.current = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => {
      clearTimeout(timeoutRef.current);
    };
  }, [value, delay]);

  return debouncedValue;
};

const SearchComponent = () => {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState([]);
  const debouncedQuery = useDebounce(query, 300);

  useEffect(() => {
    if (debouncedQuery) {
      // Expensive search operation
      searchAPI(debouncedQuery).then(setResults);
    }
  }, [debouncedQuery]);

  return (
    <input 
      type="text"
      value={query}
      onChange={(e) => setQuery(e.target.value)}
      placeholder="Search..."
    />
  );
};

// 4. Lazy loading with Intersection Observer
import { useState, useRef, useEffect } from 'react';

const LazyImage = ({ src, alt, placeholder }) => {
  const [isLoaded, setIsLoaded] = useState(false);
  const [isInView, setIsInView] = useState(false);
  const imgRef = useRef();

  useEffect(() => {
    const observer = new IntersectionObserver(
      ([entry]) => {
        if (entry.isIntersecting) {
          setIsInView(true);
          observer.disconnect();
        }
      },
      { threshold: 0.1 }
    );

    if (imgRef.current) {
      observer.observe(imgRef.current);
    }

    return () => observer.disconnect();
  }, []);

  return (
    <div ref={imgRef} className="lazy-image-container">
      {isInView && (
        <img
          src={src}
          alt={alt}
          onLoad={() => setIsLoaded(true)}
          style={{ 
            opacity: isLoaded ? 1 : 0,
            transition: 'opacity 0.3s'
          }}
        />
      )}
      {!isLoaded && <div className="placeholder">{placeholder}</div>}
    </div>
  );
};

// 5. Performance monitoring hook
const usePerformanceMonitor = (componentName) => {
  const renderStart = useRef();
  
  useEffect(() => {
    renderStart.current = performance.now();
  });

  useEffect(() => {
    const renderTime = performance.now() - renderStart.current;
    console.log(`${componentName} render time: ${renderTime.toFixed(2)}ms`);
    
    // Report to analytics
    if (renderTime > 16) { // Slower than 60fps
      console.warn(`Slow render detected: ${componentName}`);
    }
  });
};
```