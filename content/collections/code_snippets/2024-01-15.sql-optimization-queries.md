---
id: 7c8d9e0f-1a2b-3c4d-5e6f-7a8b9c0d1e2f
blueprint: code_snippet
title: 'SQL Query Optimization Techniques'
description: 'Collection of optimized SQL queries demonstrating indexing strategies, window functions, and performance improvements for common database operations.'
language: sql
programming_languages:
  - sql
difficulty: intermediate
use_cases:
  - database-optimization
  - performance-tuning
  - analytics
  - reporting
is_featured: false
external_link: null
status: published
date: 1705305600
---

```sql
-- 1. Optimized pagination with OFFSET alternative
-- Bad: Using OFFSET for large datasets
SELECT * FROM users ORDER BY id LIMIT 20 OFFSET 10000;

-- Good: Using cursor-based pagination
SELECT * FROM users 
WHERE id > 10020 
ORDER BY id 
LIMIT 20;

-- 2. Window functions for ranking and analytics
-- Get top 3 sales per region efficiently
SELECT 
    region,
    salesperson,
    sales_amount,
    ROW_NUMBER() OVER (PARTITION BY region ORDER BY sales_amount DESC) as rank
FROM sales_data
QUALIFY rank <= 3;

-- 3. Optimized aggregation with proper indexing
-- Create composite index for this query
CREATE INDEX idx_orders_date_status ON orders(order_date, status);

-- Efficient aggregation query
SELECT 
    DATE_TRUNC('month', order_date) as month,
    status,
    COUNT(*) as order_count,
    SUM(total_amount) as total_revenue
FROM orders 
WHERE order_date >= '2024-01-01'
    AND status IN ('completed', 'shipped')
GROUP BY 1, 2
ORDER BY 1 DESC, 2;

-- 4. Using EXISTS instead of IN for subqueries
-- Bad: Using IN with subquery
SELECT * FROM customers 
WHERE id IN (
    SELECT customer_id FROM orders 
    WHERE order_date >= '2024-01-01'
);

-- Good: Using EXISTS
SELECT * FROM customers c
WHERE EXISTS (
    SELECT 1 FROM orders o
    WHERE o.customer_id = c.id 
    AND o.order_date >= '2024-01-01'
);

-- 5. Common Table Expressions (CTE) for complex logic
WITH monthly_sales AS (
    SELECT 
        customer_id,
        DATE_TRUNC('month', order_date) as month,
        SUM(total_amount) as monthly_total
    FROM orders
    GROUP BY customer_id, DATE_TRUNC('month', order_date)
),
customer_trends AS (
    SELECT 
        customer_id,
        month,
        monthly_total,
        LAG(monthly_total) OVER (
            PARTITION BY customer_id 
            ORDER BY month
        ) as prev_month_total
    FROM monthly_sales
)
SELECT 
    c.customer_name,
    ct.month,
    ct.monthly_total,
    CASE 
        WHEN ct.prev_month_total IS NULL THEN 'New Customer'
        WHEN ct.monthly_total > ct.prev_month_total THEN 'Increasing'
        WHEN ct.monthly_total < ct.prev_month_total THEN 'Decreasing'
        ELSE 'Stable'
    END as trend
FROM customer_trends ct
JOIN customers c ON c.id = ct.customer_id
WHERE ct.month >= '2024-01-01'
ORDER BY c.customer_name, ct.month;

-- 6. Index optimization hints
-- For PostgreSQL - use EXPLAIN ANALYZE to check query plans
EXPLAIN (ANALYZE, BUFFERS) 
SELECT * FROM orders 
WHERE customer_id = 123 
AND order_date BETWEEN '2024-01-01' AND '2024-12-31';

-- Suggested indexes based on query patterns:
-- CREATE INDEX CONCURRENTLY idx_orders_customer_date ON orders(customer_id, order_date);
-- CREATE INDEX CONCURRENTLY idx_orders_date_amount ON orders(order_date, total_amount) WHERE status = 'completed';
```