---
id: 9a3b2c1d-4e5f-6a7b-8c9d-2e3f4a5b6c7d
blueprint: code_snippet
title: 'Go HTTP Client with Exponential Backoff Retry'
description: 'A robust HTTP client implementation in Go with automatic retry logic, exponential backoff, and configurable timeout settings.'
language: go
programming_languages:
  - go
difficulty: advanced
use_cases:
  - http-requests
  - microservices
  - resilient-systems
  - api-integration
is_featured: true
external_link: null
status: published
date: 1705564800
---

```go
package httpclient

import (
    "bytes"
    "context"
    "fmt"
    "io"
    "math"
    "net/http"
    "time"
)

// RetryableClient wraps http.Client with retry logic
type RetryableClient struct {
    client      *http.Client
    maxRetries  int
    baseDelay   time.Duration
    maxDelay    time.Duration
    retryFunc   func(*http.Response, error) bool
}

// ClientOption allows customization of the RetryableClient
type ClientOption func(*RetryableClient)

// NewRetryableClient creates a new HTTP client with retry capabilities
func NewRetryableClient(options ...ClientOption) *RetryableClient {
    client := &RetryableClient{
        client:     &http.Client{Timeout: 30 * time.Second},
        maxRetries: 3,
        baseDelay:  1 * time.Second,
        maxDelay:   30 * time.Second,
        retryFunc:  defaultRetryFunc,
    }

    for _, option := range options {
        option(client)
    }

    return client
}

// WithMaxRetries sets the maximum number of retries
func WithMaxRetries(retries int) ClientOption {
    return func(c *RetryableClient) {
        c.maxRetries = retries
    }
}

// WithTimeout sets the client timeout
func WithTimeout(timeout time.Duration) ClientOption {
    return func(c *RetryableClient) {
        c.client.Timeout = timeout
    }
}

// WithRetryFunc sets a custom retry function
func WithRetryFunc(fn func(*http.Response, error) bool) ClientOption {
    return func(c *RetryableClient) {
        c.retryFunc = fn
    }
}

// Do executes an HTTP request with retry logic
func (c *RetryableClient) Do(req *http.Request) (*http.Response, error) {
    ctx := req.Context()
    
    var resp *http.Response
    var err error
    
    // Store original body for retries
    var bodyBytes []byte
    if req.Body != nil {
        bodyBytes, err = io.ReadAll(req.Body)
        if err != nil {
            return nil, fmt.Errorf("failed to read request body: %w", err)
        }
        req.Body.Close()
    }

    for attempt := 0; attempt <= c.maxRetries; attempt++ {
        // Restore body for retry attempts
        if bodyBytes != nil {
            req.Body = io.NopCloser(bytes.NewReader(bodyBytes))
        }

        resp, err = c.client.Do(req)
        
        // Check if we should retry
        if !c.retryFunc(resp, err) {
            break
        }

        // Don't retry on the last attempt
        if attempt == c.maxRetries {
            break
        }

        // Close response body if it exists to prevent resource leaks
        if resp != nil && resp.Body != nil {
            resp.Body.Close()
        }

        // Calculate delay with exponential backoff
        delay := c.calculateDelay(attempt)
        
        select {
        case <-ctx.Done():
            return nil, ctx.Err()
        case <-time.After(delay):
            // Continue to next retry
        }
    }

    return resp, err
}

// calculateDelay implements exponential backoff with jitter
func (c *RetryableClient) calculateDelay(attempt int) time.Duration {
    // Exponential backoff: baseDelay * 2^attempt
    delay := time.Duration(float64(c.baseDelay) * math.Pow(2, float64(attempt)))
    
    // Cap at maxDelay
    if delay > c.maxDelay {
        delay = c.maxDelay
    }
    
    return delay
}

// defaultRetryFunc determines if a request should be retried
func defaultRetryFunc(resp *http.Response, err error) bool {
    // Retry on network errors
    if err != nil {
        return true
    }
    
    // Retry on server errors (5xx) and specific client errors
    if resp != nil {
        switch resp.StatusCode {
        case http.StatusTooManyRequests,     // 429
             http.StatusInternalServerError,  // 500
             http.StatusBadGateway,          // 502
             http.StatusServiceUnavailable,   // 503
             http.StatusGatewayTimeout:      // 504
            return true
        }
    }
    
    return false
}

// Get is a convenience method for GET requests
func (c *RetryableClient) Get(url string) (*http.Response, error) {
    req, err := http.NewRequest(http.MethodGet, url, nil)
    if err != nil {
        return nil, err
    }
    return c.Do(req)
}

// Post is a convenience method for POST requests
func (c *RetryableClient) Post(url, contentType string, body io.Reader) (*http.Response, error) {
    req, err := http.NewRequest(http.MethodPost, url, body)
    if err != nil {
        return nil, err
    }
    req.Header.Set("Content-Type", contentType)
    return c.Do(req)
}

// Usage Example:
func main() {
    // Create client with custom options
    client := NewRetryableClient(
        WithMaxRetries(5),
        WithTimeout(60*time.Second),
        WithRetryFunc(func(resp *http.Response, err error) bool {
            // Custom retry logic
            if err != nil {
                return true
            }
            return resp.StatusCode >= 500
        }),
    )

    // Make a request
    resp, err := client.Get("https://api.example.com/data")
    if err != nil {
        fmt.Printf("Request failed: %v\n", err)
        return
    }
    defer resp.Body.Close()

    fmt.Printf("Response status: %s\n", resp.Status)
}
```